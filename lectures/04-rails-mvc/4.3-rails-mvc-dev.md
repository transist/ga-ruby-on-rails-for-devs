Live Rails MVC Application from Scratch
=======================================

从[上一课](7-rails-basics.md)已经开始的概略，称为应用模块*RailsMVC*。

* *Gemfile*: gems, 包括Rails
* *config.ru*: 基于rack的启动脚本
* *script/rails*: 基于rails的启动脚本
* *config/environment.rb*: 应用程序初始化
* *config/boot.rb*: 应用程序启动
* *config/application.rb*: 应用程序
* *config/initializers/secret_token.rb*: 基本加密二进制大对象
* *public/index.html*: hello world

Routes
------

路由连接了一个HTTP请求和一个控制器。路由在*config/routes.rb*中声明。

``` ruby
RailsMVC::Application.routes.draw do
  # routes declared here
end
```

默认*RESTful*的路由连接了标准的HTTP动词(*GET*, *PUT*, *POST* 和 *DELETE*)和标准的资源行为(`:index`, `:show`, `:new`, `:edit`, `:update` 和 `:destroy`)。

Rakefile
--------

任务，比如像是数据库迁移，通常写在[Rake](https://github.com/jimweirich/rake)里。Rake需要*Rakefile*，来导入应用程序的代码。因此，你的Rake必须要有所有领域模型的访问权限。

``` ruby
require File.expand_path('../config/application', __FILE__)

require 'rake'

RailsMVC::Application.load_tasks
```

You can run `rake -T` to see available tasks.

    $ rake -T
    rake about # List versions of all Rails frameworks and the environment
    ...

应用程序文件夹
------------------

应用程序代码被放在*app*里面，这是一个惯例。

Asset Pipeline
--------------

*asset pipeline*能够生成JavaScript, CSS和其他的静态的东西，也为应用程序编译或者包装它们。比如，在Rails 3.1中，asset pipeline使得开发者可以使用CoffeeScript替代原来的JavaScript。

在*config/application.rb*里开启应用pipeline

    # Enable the asset pipeline
    config.assets.enabled = true

Rails里的动态HTML是渲染自*templates*。模板由多种语言写成，可执行Ruby代码。Rails使用*ERB*作为默认模板。另一个流行的模板语言是*HAML*。把`haml-rails`加入到Gemfile中，然后添加一个应用程序layout到*app/views/layouts/application.html.haml*。
layout是定义页面结构的顶层模板，包括stylesheets和javascripts。

``` haml
!!!
%html
  %head
    %title
      Rails MVC
    = stylesheet_link_tag "application"
    = javascript_include_tag "application"

  %body
    = yield
```

`stylesheet_link_tag` 和 `javascript_include_tag` 方法都被声明在[ActionView::Helpers::AssetTagHelper](http://api.rubyonrails.org/classes/ActionView/Helpers/AssetTagHelper.html)，当你可以在你的模板里面写死链接的时候，这些方法会和asset pipeline的概念一起生效，让你可以添加全局的设置，比如把assets host在其他外部CDN的*asset host*。对于Rails应用程序来说，在build的时间生成Assets并且部署到web服务器上是很常见的事情。

asset pipeline有一个概念叫*manifest file*，它包括了*directives*，使得Rails知道引用哪些文件。创建*app/assets/javascripts/application.js*作为*manifest files*之一， 那以下的*directives*就可以引用到了。

    //= require jquery
    //= require jquery_ujs
    //= require_tree .

Rails现在和jQuery一起发行了。添加‘jquery-rails’到你的Gemfile中去。

添加一点stylesheet到*app/assets/stylesheets/application.css.scss*。这里的stylesheet是用SCSS写的，SCSS是CSS的扩展，可以允许你使用变量，内嵌规则，混入，内敛的引入等。

``` css
#error_explanation {
  background-color: #f0f0f0;
  h2 {
    background-color: #c00;
    color: #fff; 
  }
  ul li {
    font-size: 12px;
    list-style: square; 
  } 
}
```

数据库配置。
----------------------

既然我们在用PostgreSQL，那我们就需要在Gemfile里加入'pg'.

Rails的配置文件是用*YAML*写的，可以执行Ruby代码。比如，你可以用`ENV['VARIABLE']`来以用一个环境变量。把*config/database.yml*加到数据库配置中。你可以用`<<:`来重复使用已经配置的代码块。

``` yaml
common: &common
  adapter: postgresql
  username: rails
  password: password
  host: localhost
  port: 5432

development:
  <<: *common
  database: rails_development

test:
  <<: *common
  database: rails_test

production:
  <<: *common
  database: rails_production
```

如果你运行`rake -T`，你会注意到没有数据库任务。这是因为我们目前只使用了action_controller部分的Rails、更改*config/application.rb*里的`require "action_controller/railtie"`为include `rails/all`

``` ruby
require 'rails/all'
```

重新运行`rake -T`来确保数据库任务已经可以显示出来了。

数据库迁移
-------------------

使用数据库的应用程序需要一个schema。我们可以创建*db/schema.rb*，里面记录着schema，但是Rails的方法是使用*database migrations*。迁移支持创建一个新的数据库和用内建的数据库版本管理工具升级一个已经存在的数据库、

创建 *db/migrate/1_create_things.rb*.

``` ruby
class CreateThings < ActiveRecord::Migration
  def change
    create_table :things do |t|
      t.string :name
      t.timestamps
    end
  end
end
```

我们忘了一个字段‘description’。现在我们创建另一个迁移来添加这个。

    $ rails generate migration add_description_to_things description:string

      invoke  active_record
      create    db/migrate/20111207001110_add_description_to_things.rb

这会生成下列的带有时间戳的迁移文件：

``` ruby
class AddDescriptionToThings < ActiveRecord::Migration
  def change
    add_column :things, :description, :string
  end
end
```

运行迁移会按照他们被创建的顺序执行，也就是按照文件名前面的数字来决定的。

本地数据库
--------------

创建一个数据库，然后迁移它从空数据库到版本1.

    rake db:create
    rake db:migrate

数据模型
----------

在Rails里， *ActiveRecord*抽象的代表了数据库访问层。

创建 *app/models/thing.rb*.

``` ruby
class Thing < ActiveRecord::Base
  validates_presence_of :name
  validates_uniqueness_of :name
end
```

验证器是一个确保字段存在和唯一的方法，在应用启动的时候，属性通过查询schema就自动生成了。

应用程序控制器
----------------------

所有的控制器都继承自`ActionController::Base`。在*app/controllers/application_controller.rb* 里面创建一个ApplicationController会比较好，这样就可以实现一些通用的逻辑，比如登陆授权等。以后再说。

``` ruby
class ApplicationController < ActionController::Base
end
```

Things Controller
-----------------

添加 *app/controllers/things_controller.rb*.

``` ruby
class ThingsController < ApplicationController
end
```

为index页得到所有的things。

``` ruby
def index
  @things = Thing.all
end
```

当用行为show或者edit一个thing的时候，通过参数获取一个已经存在的thing，参数hash的条目可以从字符串或者Symbol来获取。

``` ruby
def show
  @thing = Thing.find(params[:id])
end
```

当点击new的时候，创造一个新的thing

``` ruby
def new
  @thing = Thing.new
end
```

当从一个new或者edit页面提交一个thing的时候，持久化一个新的或者更新一个已经存在的thing模型。

``` ruby
def create
  @thing = Thing.new(params[:thing])
  if @thing.save
    redirect_to @thing, notice: 'Thing was successfully created.'
  else
    render action: "new"
  end
end

def update
  @thing = Thing.find(params[:id])
  if @thing.update_attributes(params[:thing])
    redirect_to @thing, notice: 'Thing was successfully updated.'
  else
    render action: "edit"
  end
end
```

删除一个thing.

``` ruby
def destroy
  @thing = Thing.find(params[:id])
  @thing.destroy
  redirect_to things_url
end
```

当保存模型时，错误信息会被自动存储下来，控制器的工作是重新渲染失败的Action对应的视图。创建一个partial*views/shared/_error_msg.html.haml*来显示错误信息。

``` haml
- if model.errors.any?
  .error_explanation
    %h3= "#{pluralize(model.errors.count, "error")} saving #{model.class}:"
    %ul
      - model.errors.full_messages.each do |msg|
        %li= msg
```

The `:index`, `:show`, `:new`, `:edit`, `:update` and `:destroy` methods are called *actions*. These are the default for *RESTful* routing.

Things视图
-----------

添加 *app/views/things/index.html.haml*.

``` haml
%h1 Things

%table
  %tr
    %th= "Name"
    %th
    %th

  - @things.each do |thing|
    %tr
      %td= thing.name
      %td= link_to 'Edit', edit_thing_path(thing)
      %td= link_to 'Destroy', thing, :confirm => "Are you sure?", :method => :delete

= link_to "New Thing", new_thing_path
```

与其把整个form写死在视图里，不如让我们使用一个叫做[simple_form](https://github.com/plataformatec/simple_form)的gem，还编辑一个叫*app/views/things/_form.html.haml*的partial。

``` haml
= simple_form_for @thing do |f|
  = render 'shared/error_msg', model: @thing
  = f.input :name
  = f.button :submit
```

这个form可以用于在*app/views/things/new.html.haml*中new一个新的thing。

``` haml
%h1 New Thing

= render 'form'

= link_to 'Back', things_path
```

你也可以在*app/views/things/edit.html.haml*编辑thing.

``` haml
%h1= @thing.name

= render 'form'

= link_to 'Back', things_path
```

最后，我们可以在*app/views/things/show.html.haml*显示thing。

``` haml
%ul
  %li= "Name: #{@thing.name}"

= link_to 'Edit', edit_thing_path(@thing)
|
= link_to 'Back', things_path
```

Things路由表
-------------

编辑 *config/routes.rb*.

``` ruby
RailsMVC::Application.routes.draw do
  resources :things
end
```

再看看 `rake routes`.

Links
-----

* [Rails Testing](http://guides.rubyonrails.org/testing.html)

练习
--------
* 给这个Thing模型添加一些单元测试，来确保这个Thing可以被创建、通过id查找获得、更新和被销毁(CRUD)。
* 给你的things_controller添加一系列的功能测试，以确保Thng的CRUD没问题。
* 给things视图添加一些功能视图测试，以确保视图会在`:index`时显示things的列表，`:edit`时显示forms，`:show`时显示一个thing的内容，等等。
* 跑通一个完整的创建、展示、编辑、更新和销毁Thing对象得到额外的分数。
* 路由测试会得到额外的分数。

