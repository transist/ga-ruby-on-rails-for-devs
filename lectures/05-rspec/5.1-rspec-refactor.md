使用RSpec进行重构
======================

为什么要测试?
---------

让你更有信心的重构。

* 回归测试.
* 可以让我们重构代码。

在写代码前就测试?
-----------

* 我们在开发的时候使用手动的测试，但是在最后写测试不够严谨。
* 可测试的架构和实现更加清晰，更容易进行重构。

测试和行为驱动开发。
------------------------------------

测试驱动开发TDD不是关于测试的，而是关于*设计*的。这个过程通常被成为*红灯 => 绿灯 => 重构*。

1. 写会运行失败的测试。
2. 实现你的代码的特性，让测试通过。
3. 有信心的进行重构。

行为驱动测试BDD
---

行为驱动测试是一个测试有效的方法，可以帮助开发者理解什么是测试，什么不是测试，以及怎么写测试。它关注于行为，而不是测试。

* 故事：作为一个*角色role*我想要通过什么*行为action*来达到*商业价值business value*
* 场景：给定*开场上下文initial context*和*附加上下文additional context*，当*事件event*发生了， 则产生*结果outcome*

RSpec
-----

[RSpec](http://relishapp.com/rspec) 是Ruby程序员的行为驱动开发工具。

``` ruby
# Unit Test
class DuckTest
  test "quack" do
    assert_true Duck.new.quack
  end
end

# RSpec Scenario
describe Duck
  let(:duck) { Duck.new }
  it "should quack" do
    duck.quack.should be_true
  end
end
```

如果鸭子都会嘎嘎叫，我们就可以写`duck.should_quack`。

``` ruby
describe Duck
  let(:duck) { Duck.new }
  context "in the water" do
    before(:each) do
      duck.swim
    end
    it "should quack" do
      duck.quack.should be_true
    end
  end
end
```

Gemfile
-------

把测试相关的Gem放到测试group里面这样就不会安装到生产环境了。

``` ruby
group :test do
  gem "rspec", "~> 2.7"
  gem "rspec-rails", "~> 2.7"
  gem "rspec-core", "~> 2.7"
  gem "rspec-expectations", "~> 2.7"
  gem "rspec-mocks", "~> 2.7"
end
```

你也可以为你最喜欢的工具准备`:development`group。

Spec Helper
-----------

一个helper可以包括任何的spec。它定义了RSpec的行为，比如在每个测试完成之前或者之后做什么。

``` ruby
require 'rubygems'

ENV["RAILS_ENV"] ||= 'test'

require "rails/application"
require File.expand_path("../../config/environment", __FILE__)
require 'rspec/rails'

RSpec.configure do |config|
  config.mock_with :rspec
  config.expect_with :rspec
  config.after(:all) do
    p "All tests finished."
  end
end
```

模型Spec
------------

一个简单的spec可以执行模型检验，并确保他们如期望的一样工作。创建*spec/models/thing_spec.rb*。

``` ruby
require 'spec_helper'

describe Thing do
  it "can be created with a name" do
    Thing.new({name: "thing"}).should be_valid
  end
  it "cannot be created without a name" do
    Thing.new.should_not be_valid
  end
end
```

模拟对象 vs. 真实数据
--------------------------

有时候我们想要用真是的数据库来测试，而不是依赖于模拟对象。这意味着我们需要为每一次测试可用的干净的数据库拷贝.有一个gem可以做这样的事情。

``` ruby
gem "database_cleaner"
```

我们不需要每次都重建Schema，只需要截断数据表。把设置加入到*support/config/database_cleaner.rb*。

``` ruby
RSpec.configure do |config|
  config.before(:suite) do
    DatabaseCleaner.strategy = :truncation
  end
  config.before(:each) do
    DatabaseCleaner.clean
  end
end
```

通过*spec/spec_helper.rb*来include文件。

``` ruby
[ "support/config/*.rb", "support/*.rb" ].each do |path|
  Dir["#{File.dirname(__FILE__)}/#{path}"].each do |file|
    require file
  end
end
```

确保你有一个测试用的schema.

    rake db:test:prepare

运行测试

    rspec spec

Specs控制器和测试桩
-------------------------

对`Thing.method`可能不是一件简单的事情，但是我们不会试着在一个控制器测试里面进行测试。我们可以使用*测试桩*，用一个简单的方法实现或者通过*模拟对象*替换整个`Thing`的实例、为了定义它，我们加了一个`mock_thing`方法，可以接受可选的hash参数，从已知的方法种返回结果。通过加入对`as_null_object`的调用，我们可以造成模拟对象从其他的方法中返回nil。

``` ruby
def mock_thing(stubs={})
  @mock_thing ||= mock_model(Thing, stubs).as_null_object
end
```

对于`:index`方法，我们想要确保`@things`已经被指派为things的集合。因为我们在用一个mock对象，我们必须做一个测试桩到类方法`Thing.all`里面，返回`Thing`实例的集合。

``` ruby
describe "GET index" do
  it "assigns all things to @things" do
    Thing.stub!(:all).and_return [ mock_thing ]
    get :index
    assigns(:things).should eq [ mock_thing ]
  end
end
```

这个测试表述了控制器的责任，就是去调用`Thing.all`，并且把结果指派给`@things`。

练 习
--------

为剩余的方法实现specs

* GET new
* GET edit
* POST create
* PUT update
* DELETE destroy

控制器 Specs 和 Fabricators
-------------------------------

模拟对象对简单的对象效果很好。很多Rubyist更倾向于在测试中使用真实的对象，特别是更高层的整体测试。通过调用`Thing.create!`就可以制造这些对象，但是这个方法并没有提供很好的默认情况或者唯一的值。*fabricator* ，一个被称为[fabrication](https://github.com/paulelliott/fabrication)的gem可以做这样的事情

``` ruby
gem "fabrication"
```

为*Thing* 在`spec/fabricators/thing_fabricator.rb`里添加一个fabricator。

``` ruby
Fabricator(:thing) do
  name { Fabricate.sequence(:name) { |i| "Thing Number #{i}" } }
end
```

我们现在可以使用一个真正的*Thing*来进行测试了。

``` ruby
describe "PUT update" do
  before(:each) do
    @thing = Fabricate(:thing)
  end
  it "updates thing" do
    put :update, :id => @thing.id.to_s, :thing => { 'name' => 'updated' }
    @thing.reload.name.should == 'updated'
  end
end
```

练习
--------

用Fabricator来实现剩余的Thing controller的测试

View Specs
----------

控制器的代码是不是在view spec里执行的。因此，你必须明确的指派变量，否则会被一个控制器行为指派。以下的spec是`spec/views/things/index.html.haml_spec.rb`的内容。

``` ruby
describe "things/index.html.haml" do
  before(:each) do
    @thing = Fabricate(:thing)
    assign(:things, Thing.all)
  end
  it "renders a list of things" do
    render
    assert_select "tr>td", :text => @thing.name, :count => 1
  end
end
```

整体测试
-----------------

当我们可以测试一个单独的部件的时候，我们也想要确保整个*Thing*的特性是没问题的。为了达到这样的目的，我们可以通过用[capybara](https://github.com/jnicklas/capybara) 和 [selenium](http://seleniumhq.org/)来操作浏览器执行真正的用户行为。

``` ruby
require 'spec_helper'

feature "Things", :driver => :selenium do
  scenario "are displayed in a table" do
    thing = Fabricate(:thing)
    visit "/things"
    page.should have_css "td", text: thing.name
  end
  scenario "can be destroyed" do
    thing = Fabricate(:thing)
    visit "/things"
    page.evaluate_script('window.confirm = function() { return true; }')
    click_link "Destroy"
    Thing.count.should == 0
  end	
end
```

另一个办法是，指定`:driver => :selenium`为`:js => true`

充满信心的进行重构
----------------------

控制器支持过滤器，可以避免复制黏贴。这被称为*DRYing*一个控制器。*DRY*是*Don't Repeat Yourself*的缩写。现在我们有specs可以覆盖应用程序，我们可以充满信心的进行重构了。

``` ruby
class ThingsController < ApplicationController
  before_filter :get_thing, :only => [ :edit, :show, :update, :destroy ]
  def get_thing
    @thing = Thing.find(params[:id])
  end
end
```

[Other filters](http://rails.rubyonrails.org/classes/ActionController/Filters/ClassMethods.html) include `:after_filter`, `:around_filter`, etc.

练 习
--------

修改应用使其当一个用户请求一个并不存在的*Thing*的时候。重定向到*404 Not Found*页面，练习你的TDD，最开始，写两个通不过的控制器和另一个通不过的验收测试。

练 习
--------

继续扩展这个应用，我们用[devise gem](https://github.com/plataformatec/devise)来做授权系统。只有授权的用户才可以创建，编辑和销毁things。写一些测试。然后部署应用到heroku.作为一个草略的目标，如果系统里没有用户，应该提醒你创建一个。

RSpec输出
------------

创建 *.rspec* 

    --format nested
    --color

你也可以尝试 [fuubar](https://github.com/jeffkreeftmeijer/fuubar) 进度条.这使得你在测试的时候看起来更漂亮。

Spork
-----

你必须注意到Rails需要一点时间来加载。Rails是一个很大的代码库，每次你运行`rspec`的时候都需要解析。把[spork](https://github.com/sporkrb/spork)加到你的`:test` group以避免每次运行测试的时候都重新载入Rails.

把 `--drb` 加到 *.rspec* 然后 对 *spec/spec_helper.rb*做一些改变.

``` ruby
require 'rubygems'
require 'spork'

Spork.prefork do

  ENV["RAILS_ENV"] ||= 'test'

  require "rails/application"
  require File.expand_path("../../config/environment", __FILE__)
  require 'rspec/rails'

  RSpec.configure do |config|
    config.mock_with :rspec
    config.expect_with :rspec
    config.after(:all) do
      p "All tests finished."
    end
  end

end

Spork.each_run do

  [ "support/config/*.rb", "support/*.rb" ].each do |path|
    Dir["#{File.dirname(__FILE__)}/#{path}"].each do |file|
      require file
    end
  end

end
```

