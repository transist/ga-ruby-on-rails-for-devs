Rails里的Cache
================

Cache使用一个快速的，通常是内存存储，来持久化需要很长时间来获得或者计算的数。cache通过*key*来唯一确定数据，但是通常只保存给定的*时间段*。

Page Caching
------------

*WidgetsController*产生两条查询：一条来查询widgets，另外一条查询属于每一个widget的gadgets。

```
Processing by WidgetsController#index as HTML
  Widget Load (2.2ms)  SELECT "widgets".* FROM "widgets" 
  Gadget Load (0.5ms)  SELECT "gadgets".* FROM "gadgets" WHERE "gadgets"."widget_id" = 1
  Gadget Load (0.5ms)  SELECT "gadgets".* FROM "gadgets" WHERE "gadgets"."widget_id" = 2
  Rendered widgets/index.html.haml within layouts/application (171.0ms)
Completed 200 OK in 195ms (Views: 134.5ms | ActiveRecord: 43.9ms)
```
我们可以开始cache widgets了。

``` ruby
class WidgetsController < ApplicationController

  def index
    @widgets = get_cached_widgets
  end

  def get_cached_widgets
    Rails.cache.fetch("widgets", :expires_in => 10.minutes) do
      Widget.all
    end
  end

end
```
注意ActiveRecord的查询时间从43.9ms减少到了9.0ms。

```
Processing by WidgetsController#index as HTML
  Gadget Load (8.3ms)  SELECT "gadgets".* FROM "gadgets" WHERE "gadgets"."widget_id" = 1
  Gadget Load (0.7ms)  SELECT "gadgets".* FROM "gadgets" WHERE "gadgets"."widget_id" = 2
  Rendered widgets/index.html.haml within layouts/application (33.9ms)
Completed 200 OK in 49ms (Views: 39.4ms | ActiveRecord: 9.0ms)
```

一个类似的效果可以在*environments/development.rb*里面启用*perform_caching*之后用`caches_page` helper来完成。这个可以cache整个页面的输出。

``` ruby
config.action_controller.perform_caching = true
```

``` ruby
class WidgetsController < ApplicationController

  caches_page :index

  def index
    @widgets = Widget.all
  end

end
```

Cache Expiration
----------------

Cache可以设置过期时间。

``` ruby
Rails.cache.fetch("widgets", :expires_in => 10.seconds) do
  Widget.all
end
```

或者可以明确的设定谁过期。

``` ruby
def create
  expire_page :action => :index
end
```

Action Caching
--------------

Cache页面不能和授权合并，因为过滤器会运行含有cache的代码块，想要cache一个action的输出，要使用*action caching*。

``` ruby
class WidgetsController < ApplicationController

  before_filter :authenticate!
  caches_action :index

  def index
    @widgets = Widget.all
  end

end
```

Fragment Caching
----------------

可以用*fragment caching*来cache页面特定的部分。

``` erb
<% cache('all_widgets') do %>
  # ...
<% end %>
```

Sweepers
--------

不同于把cache过期逻辑放到控制器里，我们可以通过实现一个观察者来*清理* cache。

``` ruby
class WidgetSweeper < ActionController::Caching::Sweeper
  observe Widget
 
  def after_create(widget)
    expire_cache_for(widget)
  end
 
  def after_update(widget)
    expire_cache_for(widget)
  end
 
  def after_destroy(widget)
    expire_cache_for(widget)
  end
 
  private

    def expire_cache_for(widget)
      expire_page(:controller => 'widgets', :action => 'index')
      expire_fragment('all_widgets')
    end

end
```

测试
-------

在*config/environments/test.rb*里启用cache。

``` ruby
config.action_controller.perform_caching = true
```

以下的控制器测试期望*Widget.all*能在页面被第一次访问的时候调用。

``` ruby
it "should cache :index action" do
  Widget.should_receive(:all).once
  2.times { get :index }
end
```
我们也需要在运行过程中清除Rails的cache。

``` ruby
config.before :each do
  Rails.cache.clear
end
```

