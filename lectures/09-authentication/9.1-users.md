用户授权系统
===================

我们会扩展我们在[5.1 RSpec Refactor](https://github.com/dblock/class_RubyForDevs/tree/master/5-rspec/5.1-rspec-refactor-exercises)里面已经开发的应用作为起点。

我们用[twitter-bootstrap-rails](https://github.com/seyhunak/twitter-bootstrap-rails)作漂亮的UI，添加[shoulda-matchers](https://github.com/thoughtbot/shoulda-matchers)来DRY不重复我们的specs.

``` ruby
gem "twitter-bootstrap-rails"

group :development, :test do
  gem "shoulda-matchers"
end
```

生成Twitter bootstrap layout

    rails g bootstrap:install

用户模型
----------

存储用户的信息的基础模型。

    rails generate model User name:string email:string

使用验证器，可以用正则表达式来验证Email是不是可用的。

``` ruby
class User
  attr_accessible :name, :email
  validates_uniqueness_of :email
  validates_presence_of :email
  validates :email, :format => { :with => /\A[\w+\-.]+@[a-z\d\-.]+\.[a-z]+\z/i }
  validates_presence_of :name
end
```

Rails验证器对于避免不合格式的用户数据很有用。但是我们也必须强制要求email在数据库里的唯一性.在数据库迁移里，添加一个唯一的限制到`users`表。

    rails generate migration add_email_uniqueness_index

``` ruby
class AddEmailUniquenessIndex < ActiveRecord::Migration
  def up
    add_index :users, :email, :unique => true
  end
  def down
    remove_index :users, :email
  end
end
```

创建一个基础的表格来注册一个新的用户（从*thing*拷贝过来），然后通过*config/routes.rb*重定向注册到一个用户Action.

``` ruby
match '/signup',  :to => 'users#new'
```

密码
--------

强制一个最小和最长的长度，并且要有确认密码，但是不要把密码明文存储在数据库内。

``` ruby
validates :password, :presence => true, :confirmation => true, :length => { :within => 6..40 }

attr_accessible :encrypted_password
attr_accessor :password, :password_confirmation
```

只有被加密过的密码才能被存储下来。

    rails generate migration add_password_to_users encrypted_password:string

在一个user被存储之前，生成一个加密的密码。

``` ruby
before_save :encrypt_password

private

  def encrypt_password
    self.encrypted_password = ::User.encrypt(self.password)
  end

  def self.encrypt(string)
    Digest::SHA2.hexdigest(string)
  end
```

我们也可以写一个方法来检查密码是否是正确的。

``` ruby
def has_password?(pwd)
  self.encrypted_password == ::User.encrypt(pwd)
end
```

添加密码区域到注册Form*views/users/_form.html.haml*。

``` haml
= simple_form_for @user do |f|
  = render 'shared/error_msg', model: @user
  = f.input :name
  = f.input :email
  = f.input :password
  = f.input :password_confirmation
  = f.button :submit
```

RESTful Session
---------------

我们可以认为登陆是一个资源。在用户输入了一个有效的email和密码之后，应用会创建一个新的用户Session，在用户登出的时候销毁它。

让我们从输入email和密码视图的*app/views/sessions/new.html.haml*开始。我们现在还没有session，所以我们可以使用`:session` symbol。这个form会post到SessionsController的`:create` action。

``` haml
= simple_form_for :session, :url => sessions_path do |f|
  = f.input :email
  = f.input :password
  = f.button :submit, :value => "Sign In"
```

控制器

``` ruby
class SessionsController < ApplicationController

  def new
    # sign-in form
  end

  def create
    # sign-in form posted, log-in
  end

  def destroy
    # user loging out
  end

end
```

Sessions 路由. 我们可以创建更多可读的路径。

``` ruby
resources :sessions, :only => [:new, :create, :destroy]

match '/signup',  :to => 'users#new'
match '/signin',  :to => 'sessions#new'
match '/signout', :to => 'sessions#destroy'
```

我们会想要在多个的控制器里访问session的信息，所以我们创建*app/helpers/session_helper.rb*。

``` ruby
module SessionsHelper

  def sign_in(user)
    # log-in an existing user
  end

  def sign_out
    # logout current user
  end

  def signed_in?
    # true if signed in
  end

  def current_user
    # current user, if any
  end

end
```

重定向到登陆.
-----------------

一个未授权的用户会被重定向到login。

``` ruby
class ApplicationController < ActionController::Base
  include SessionsHelper

  before_filter :authenticate

  def authenticate
    redirect_to :signin unless signed_in?
  end

end
```

我们会重定向到SessionsController，甚至都不应该试着授权用户。
We're redirecting to the `SessionsController`, which shouldn't try to authenticate users.

移除最后的静态页面
---------------------------

添加一个`HomeController`和显示当前用户的视图。

``` haml
%h1 Hello World

You're logged in as
=current_user
```

重定向应用的root到这个控制器。

``` ruby
    root :to => "home#index"
```

Session Helper
--------------

我们想把session管理的功能给群组化，比如`current_user`，放到一个单独的可以被独立测试和多个控制器所使用的模块里。

``` ruby
module SessionsHelper

  def sign_in(user)
    cookies.permanent.signed[:auth_token] = [user.id, user.cookie]
    self.current_user = user
  end

  def sign_out
    cookies.delete :auth_token
    self.current_user = nil
  end

  def signed_in?
    ! current_user.nil?
  end

  def current_user
    @current_user ||= user_from_cookie
  end

  def current_user=(user)
    @current_user = user
  end

  private

    def user_from_cookie
      User.authenticate_with_cookie(* remember_token)
    end

    def remember_token
      cookies.signed[:auth_token] || [nil, nil]
    end

end
```

这里的`cookies`方法属于`ActionController`，提供了一个有着在客户端浏览器持久化和操纵cookie接口的方法。了解更多关于cookie接口的信息，参见[这里](http://apidock.com/rails/ActionDispatch/Cookies)

User
----

给定一个email和一个密码，就可以定位到一个存在的`User`.

``` ruby
def self.authenticate(email, pwd)
  user = find_by_email(email)
  return nil  if user.nil?
  return user if user.has_password?(pwd)
end
```

给定一个user ID和cookie，也可以定位到一个存在的`User`。

``` ruby
def self.authenticate_with_cookie(id, cookie)
  user = find_by_id(id)
  (user && ::User.encrypt(user.encrypted_password) == cookie) ? user : nil
end

def cookie
  ::User.encrypt(encrypted_password)
end
```

用户控制器
---------------

允许注册新用户在访问`:new`和`:create`路径的时候不用授权。不然的话就会被重定向到登陆页面。

``` ruby
skip_filter :authenticate, :only => [ :new, :create ]
```

Sessions 控制器和 Login
----------------------------

允许登陆的时候访问`:new`和`:create`路径不用授权。否则浏览器会重定向到一个登陆页面。一个新的session是在查找了用户的email和密码之后才建立的。

``` ruby
class SessionsController < ApplicationController
  skip_filter :authenticate, only: [ :new, :create ]

  def new
    render 'new'
  end

  def create
    user = User.authenticate(params[:session][:email], params[:session][:password])
    if user.nil?
      flash.now[:error] = "Invalid email/password combination."
      render 'new'
    else
      sign_in user
      redirect_to user
    end
  end

  def destroy
    sign_out
    redirect_to root_path
  end

end
```

登出链接
-----------

登出链接销毁当前用户的session.

``` haml
=link_to "Sign Out", signout_path, :method => :delete
```

