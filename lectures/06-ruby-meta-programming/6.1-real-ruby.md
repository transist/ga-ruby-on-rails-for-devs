真实的Ruby和元编程
==============================

星号, Splat 和 Hash
------------------------

收集剩余的参数到数组中。

``` ruby
def splat(* args)
  p "#{args.length}: #{args}"
end

splat 1, 2, 3, 4 # 4: [1, 2, 3, 4]
```

我们还可以怎么传递变化的参数呢？用Hash：

``` ruby
def var(args)
  p "#{args.inspect}"
end

var "1" => "2", "3" => "4" # { "1" => "2", "3" => "4" }
```

Blocks和Yields
-----------------

如果参数的前面带有一个&记号的话，就可以接收一个'do'代码块，事实上这是一个‘Proc’

``` ruby
def f1(& b)
  puts "#{b.class}"
  yield 
end

f1 do
  puts 'hello world' # Proc, hello world
end
```

我们可以利用这个来创建一个可以被指派、读取和使用的类变量。

``` ruby
class F

  def thing=(value)
    @thing = value
  end

  def thing(& b)
    if block_given?
      yield @thing
    else
      @thing
    end
  end

end

f = F.new
p f.thing # nil

f.thing = 42
p f.thing # 42

f.thing do |value|
  p value * 2 # 84
end
```

在'File'里面可以用到同样的办法在代码块中关闭文件句柄。

``` ruby
File.open(filename) do |h|
  # read file
end

# file handle is closed
```

Lambda vs. Proc
---------------

两者都是匿名的函数式编程，在行为上很相似。

``` ruby
f = Proc.new { p @thing }
f.call # nil

l = lambda { p @thing }
l.call # nil

@thing = 42

f.call # 42
l.call # 42
```

一个精妙的区别是两者强制[*参数数量*](http://en.wikipedia.org/wiki/Arity)的方式。

``` ruby
f = Proc.new { |t| p t }
f.call 1, 2 # 1

l = lambda { |t| p t }
l.call 1, 2 # ArgumentError
```

另一个区别是他们[处理返回](http://stackoverflow.com/questions/626/when-to-use-lambda-when-to-use-proc-new)的方式

Methods和Send
----------------

Ruby方法都是消息。‘send’方法调用了方法。

``` ruby
p "hello world".send(:upcase) # "HELLO WORLD"
```

当你使用&操作符的时候，你把一个对象转换成了一个‘Proc’过程。现在我们就可以在数组的每个元素上调用方法了。

``` ruby
class Symbol
  alias_method :old_to_proc, :to_proc
  def to_proc
    puts "to_proc for symbol `#{self}`"
    old_to_proc
  end
end

p ["hello", "world"].map(&:upcase) # to_proc for symbol `upcase`, ["HELLO", "WORLD"]
```

元编程
----------------

Ruby因为*元编程*功能而很出名，这种能力可以写出能够写代码的代码。接下来，你可以找到对通用类方法attr_accessor的重新实现，这个helper为你的成员变量创建了getter和setter方法：

``` ruby
class Thing
  def self.attr_accessor(*accessors)
    accessors.each do |accessor|
      define_method(accessor) { instance_variable_get "@#{accessor}" }
      define_method("#{accessor}=") { |val| instance_variable_set "@#{accessor}", val }
    end
  end

  attr_accessor :name # invokes the class method above to generate the instance methods 'name' and 'name='
end
```

其中最有趣的一个特性就是`method_missing`，这是一个在接收到‘NoMethodError’前定义方法的机会。这是一个[Kernel](http://www.ruby-doc.org/core-1.9.3/Kernel.html)方法。

``` ruby
class Thing
  def method_missing(method, * args)
    if method.to_s[0..2] == "to_"
      "i am a #{method.to_s[3..-1]}"
    else
      super
    end
  end
end

p Thing.new.to_computer # "i am a computer"
# p Thing.new.invalid # NoMethodError
```

在其他语言里元编程很困难。在Ruby很简单和透明。就像Matz说过那样：*"Have fun, be safe and use your imagination!"*.

Exercise
--------

实现一个叫‘Gadget’的模型，还有一个叫‘Widget’的模型用纯Ruby实现了一个callback。一个widget应该包含一系列的Gadgets。每次一个widget接收一个gadget，调用一个‘:when_added’ Callback。每次widget变成空的，就激活‘:when_empty’callback.

