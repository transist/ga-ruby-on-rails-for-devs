Rails里的REST
=============

在Rails，一个RESTful的资源通过*config/routes.rb*，被表达在*routing*里。

``` ruby
RailsMvc::Application.routes.draw do
  resources :things
end
```

一个资源，多种的表述
----------------------------------

* An HTML representation: http://localhost:3000/things/1
* A TEXT representation: http://localhost:3000/things/1.txt
* A JSON representation: http://localhost:3000/things/1.json

*Things*控制器已经曝露了RESTful资源，但是还需要返回不同的格式。

``` ruby
def show
  @thing = Thing.find(params[:id])
  respond_to do |format|
    format.html
    format.json { render :json => @thing }
    format.text { render :text => @thing }
  end
end
```

创建Resources
------------------

返回不同的格式和*controllers/things_controller.rb*里不同的状态代码。

``` ruby
def create
  @thing = Thing.new(params[:thing])
  if @thing.save
    respond_to do |format|
      format.html { redirect_to @thing, notice: "Thing was successfully created." }
      format.json { render :json => @thing, :status => 201 }
    end
  else
    respond_to do |format|
      format.html { render action: "new" }
      format.json { render :json => { "errors" => @thing.errors }, :status => 400 }
    end
  end
end
```

从命令行使用*curl*。

    $ curl -d "thing[name]=new%20thing&thing[description]=description" http://localhost:3000/things.json

返回*201 Created*。

    HTTP/1.1 201 Created
    Content-Type: application/json

    { "thing":{"created_at":"2012-02-13T14:10:07Z","description":null,"id":5,"name":"new thing","updated_at":"2012-02-13T14:10:07Z"}}

更新Resources
------------------

    $ curl -X PUT -d "thing[name]=updated%20thing" -H "Accept: application/json" http://localhost:3000/things/1

更新一个记录应该返回*200 OK*。

``` ruby
def update
  @thing = Thing.find(params[:id])
  if @thing.update_attributes(params[:thing])
    respond_to do |format|
      format.html { redirect_to @thing, notice: "Thing was successfully updated." }
      format.json { render :json => @thing, :status => 200 }
    end
  else
    respond_to do |format|
      format.html { render action: "edit" }
      format.json { render :json => { "errors" => @thing.errors }, :status => 400 }
    end
  end
end
```

销毁Resources
--------------------

    curl -X DELETE -H "Accept: application/json" http://localhost:3000/things/1 -v

一般来说，API返回已经被删除的object。

``` ruby
def destroy
  @thing = Thing.find(params[:id])
  @thing.destroy
  respond_to do |format|
    format.html { redirect_to things_url }
    format.json { render :json => @thing, :status => 200 }
  end
end
```

异常处理 Handling
------------------

当资源不存在的时候返回404。

``` ruby
def get_thing
  begin
    @thing = Thing.find(params[:id])
  rescue ActiveRecord::RecordNotFound => e
    respond_to do |format|
      format.html { render file: "public/404.html", status: 404 }
      format.json { render :json => { "errors" => e.message }, :status => 404 }
    end
  end
end
```

一般来说，我们可以把这些错误处理都放到`ApplicationController`。

``` ruby
class ApplicationController < ActionController::Base

  rescue_from Exception, :with => :handle_exception
  rescue_from ActiveRecord::RecordNotFound, :with => :record_not_found

  private

    def record_not_found(e)
      respond_to do |format|
        format.html { render file: "public/404.html", status: 404 }
        format.json { render :json => { "errors" => e.message }, :status => 404 }
      end
    end

    def handle_exception(e)
      respond_to do |format|
        format.html
        format.json  { render :json => { "errors" => e.message }, :status => 500 }
      end
    end

end
```

使用JavaScript
---------------------

我们可以通过[jquery-ui-bootstrap-rails](https://github.com/jaimie-van-santen/jquery-ui-bootstrap-rails) gem来使用JQuery 风格 UI。

*:index* action 返回了参数`term`, 渲染为JSON或者HTML。

``` ruby
def index
  if params[:term]
    @things = Thing.find(:all,:conditions => ['name LIKE ?', "#{params[:term]}%"],  :limit => 5, :order => 'name')
  else
    @things = Thing.all
  end
  respond_to do |format|
    format.html
    format.json { render :json => @things }
  end
end
```

添加一个form到*index.html.haml*页面里面，以及一段包含添加一个JQuery自动补全`:name`属性的JavaScript到这个form。

``` haml
= javascript_include_tag 'things'

=form_for :thing do |f|
  =f.text_field :name, :class => 'select'
```

我们会给出每行*thing*的ID。

``` haml
- @things.each do |thing|
  %tr{id: thing.id}
```

Javascript放到*app/assets/javascripts/things.js.coffee*。一旦这个文档被加载。输入框用JQuery UI 插件的[autocomplete](http://jqueryui.com/demos/autocomplete/)功能从*things.json*实现自动完成。向上选择会自动定位表内的一行，并且高亮之。

``` javascript
$(document).ready ->
  $('input#thing_name')
    .autocomplete({
      source: '/things.json',
      select: ( event, ui ) ->
        row = $("tr[id=#{ui.item.thing.id}]")
        row.addClass("selected")
        false
    })
    .data("autocomplete")._renderItem = (ul, item) ->
	      $("<li></li>")
		      .data("item.autocomplete", item)
		      .append("<a>#{item.thing.name}</a>")
		      .appendTo(ul);
```

被选择的CSS被替换到*app/assets/stylesheets/application.css.scss*。

``` css
tr.selected {
  background-color: green;
  color: white;
  font-weight: bold;
}
```

不用Rails玩REST
------------------

如果你不使用Rails MVC，这里有若干流行的用Ruby曝露RESTful API的方法。

* [Sinatra](http://www.sinatrarb.com/)
* [Grape](https://github.com/intridea/grape)
* [WebMachine](https://github.com/seancribbs/webmachine-ruby)

