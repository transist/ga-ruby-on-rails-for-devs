进阶Active Record
======================

以下ActiveRecord的特性允许进行在基础的持久化功能之上进行一些高级的功能。

Callbacks 和 Observers
-----------------------

内建的callbacks，比如`before_validation`，允许参与进对象的生命周期。Callback实例方法。

``` ruby
class Widget < ActiveRecord::Base
  after_save :saved

  def saved
    Rails.logger.log "created Widget with id=#{id} and name=#{name}"
  end

  before_create do |widget|
    widget.name = widget.name.capitalize
  end
end
```

你也可以创建观察者对象，这起源于`ActiveRecord::Observer`，用来`观察模型`和实现回调。

``` ruby
class WidgetObserver < ActiveRecord::Observer
  def after_save(model)
    Rails.logger.log "created Widget with id=#{model.id} and name=#{model.name}"
  end
end
```

你可以在应用的*config/application.rb*里注册你的观察者。

``` ruby
config.active_record.observers = :widget_observer
```

事务
------------

``` ruby
Model.transaction do
   # wraps commands within a transaction
end
```

单表继承
------------------------

Rails允许多个类基于一张表，会使用type列来决定是哪个类。

    $ rails g migration add_type_to_gadgets type:string

这个语句会生成以下的*db/schema.rb*:

``` ruby
create_table "gadgets" do |t|
  t.string   "type"  # type defines the class this row belongs to (HeaderGadget, SidebarGadget, etc)
  t.string   "name"
  t.datetime "created_at"
  t.datetime "updated_at"
end
```

根据在type列的字符串，以下的类会得到实例化：

``` ruby
class Gadget; end;

class MusicGadget
  def playlist
    # retrieves music playlist
  end
end

class SidebarGadget
  def dock
    # docks the gadget to a particular bar
  end
end
```

这样根据type就可以做各种功能了，但是仍然需要一个通用的持久化。

再一次的提到[convention over configuration](http://en.wikipedia.org/wiki/Convention_over_configuration)在这里的实践, 因为通过为单表继承所保留的*type*列。如果不是为了单表继承的话，最好不要重写*type*列。

多态关联 Polymorphic Associations
------------------------

在对象之间创建，属于多个模型的多态关系、

``` ruby
class WebPage < ActiveRecord::Base
  has_many :widgets, as: :displayable
end

class Desktop < ActiveRecord::Base
  has_many :widgets, as: :displayable
end

class Widget < ActiveRecord::Base
  belongs_to :displayable, polymorphic: true
end
```

为了让以下的场景成为可能，多态接口*Widget*必须定义外键列和type列。

``` ruby
create_table "widgets", :force => true do |t|
  t.string   "name"
  t.datetime "created_at"
  t.datetime "updated_at"
  t.integer "displayable_id"
  t.string "displayable_type"
end
```

什么时候使用它们
----------------

* 多态关联（不同的类，多张表）
* 单表继承（不同的类，同一张表）
* 带有条件的单类（一个类，一张表）

Gems of Interest
----------------

``` ruby
group :test do
  gem 'rspec-rails'
  gem 'capybara'
  gem 'fabrication'
  gem 'ffaker'
  gem 'shoulda-matchers'
end
```

Points of Interest
-----------------

1. Rails [migrations](http://guides.rubyonrails.org/migrations.html)
    - `$ rails g migration add_gadgets_to_widgets gadget_id:integer`
2. `belongs_to`, `has_many`, and [`:through`](http://api.rubyonrails.org/classes/ActiveRecord/Associations/ClassMethods.html)
    - `has_many :controls, through: :gadgets`
3. Using the object mother gem [`fabrication`](http://fabricationgem.org/) with gem [`ffaker`](https://github.com/EmmanuelOga/ffaker) to create fake data
    - `Fabricate(:widget)`
4. Testing associations and validations with ['rspec-rails'](https://github.com/dchelimsky/rspec-rails) and the gem [`shoulda-matchers`](https://github.com/thoughtbot/shoulda-matchers)
    -  `it {should validate_presence_of :type } `
5. [ActiveRecord Callbacks](http://api.rubyonrails.org/classes/ActiveRecord/Callbacks.html): `before_validation`, `after_validation`, `before_save`, etc
6. [Single Table Inheritance](http://code.alexreisner.com/articles/single-table-inheritance-in-rails.html) using the `type` column
7. [Polymorphic Associations](http://railscasts.com/episodes/154-polymorphic-association) with the `displayable_id` and `displayable_type` column

练 习
--------

* 创建一个多态的关联，要有两个模型分别叫`Instructor` 和 `Scout`，它们都拥有`badges`、
* 创建一个单表继承一个模型`Animal`有`Fish`和`Bird`两个种类。给合适的类创建`swim`和`fly`方法。

