Active Record基础
===================

ActiveRecord是Rails默认的对象关系映射，也是*模型驱动设计*的核心。它倡导*胖*模型*瘦*控制器、

* 包装数据
* 封装数据库连接
* 添加领域逻辑

需要注意的很重要的一点，不同于Hibernate或者JPA，ActiveRecord是一个抽象泄露，也就是说，它只是让SQL变得更容易了。但还是推荐要去理解一下SQL的底层的复杂性。

基础
------

一个数据库表就是一个Ruby class

``` ruby
class Widget < ActiveRecord::Base
  # class implementation
end
```

表名是复数形式，类名是单数形式。在‘Widget’类以下的表名是`widgets`。

属性是从*db/schema.rb*中推测出的.

``` ruby
create_table "widgets", :force => true do |t|
  t.string   "name"
  t.datetime "created_at"
  t.datetime "updated_at"
end
```

如果`Widget`有一个属性叫`name`，`Widget`类会自动得到一个叫`name`的属性。

``` ruby
Widget.new.name
```

所有的表都有一个整数ID。*widgets*表有一个序列化的*id*属性。在schema文件中并没有明确表述出这个属性，但是会自动的添加到所有的模型中。

``` ruby
Widget.new.id # id will be null because the database hasn't set the id yet.

Widget.create.id # id will be set upon successful creation.
```

使用*migrations*进行部署和升级。

保存对象
--------------

* `save` 和 `save!`
* `update_attributes` 和 `update_attributes!`

如下所示:

``` ruby
widget = Widget.new
widget.save # attempts to save the widget, returns true or false
widget.errors # contains errors from save, if any
widget.save! # raises an exception instead
```

查询
--------

* `Widget.find(:first)`
* `Widget.find(:all)` or `Widget.all`
* `Widget.find(1)`

使用`method_missing`来实现通过属性值查找。比如`find_by_name`。

提供了一个有泄露抽象（leaky abstraction）和轻量级的SQL抽象

``` ruby
Widget.find(:all,
  conditions: [ "username = ? and password = ?", username, password ],
  limit: 10,
  offset :10,
  order: 'username',
  joins: 'accounts')
```

通过链状方法调用以下的示例：

``` ruby
Widget.where("username = ? and password = ?", username, password).limit(10).offset(10).order('username').joins(:accounts)
```

也可以使用 `:select`, `:group` and `:include` (eager loading).

验证器
----------

通过‘validate’，`validate_on_create`，`validate_on_update`以及内建的`validates_presence_of`和`validates_uniqueness_of`在Callback上进行验证，

``` ruby
class Widget < ActiveRecord::Base
  validates :name, :presence => true, :length => { :minimum => 3 }
end

widget = Widget.create
widget.errors # => {:name => ["can't be blank", "is too short (minimum is 3 characters)"]}
```


关联
------------

* `belongs_to`
* `has_one`
* `has_many`
* `has_and_belongs_to_many` (HABTM)

关联给类添加了可以在SQL级别使用*joins*的方法。比如`widget.gadgets`。

``` ruby
class Widget < ActiveRecord::Base
  has_many :gadgets
end

class Gadget < ActiveRecord::Base
  belongs_to :widget
end

widget = Widget.create!({ :name => "test" })
widget.gadgets << Gadget.create!
```

如果你运行以上的代码，你会接触到一个异常。

    SQLException: no such column: gadgets.widget_id

在含有`belongs_to`的模型里，必须要给定一个外键，这样才能完成关联。比如在`gadget`:

    $ rails g migration add_widget_id_to_gadgets widget_id:integer

添加*gadgets* 表到 *db/schema.rb*.

``` ruby
create_table "gadgets", :force => true do |t|
  t.integer  "widget_id" # rails will automatically use this column to associate a gadget with a widget.
  t.datetime "created_at"
  t.datetime "updated_at"
end
```

注意一下由于[convention over configuration](http://en.wikipedia.org/wiki/Convention_over_configuration)原则，系统会访问名为`widget_id`的外键，Rails假设外键是以模型名字来标注外键属性名的，比如`widget`后缀加上`_id`。也会推断出表名的symbol是`:widgets`。


以下演示了如何明确的设置这些值:

``` ruby
class Gadget < ActiveRecord::Base
  belongs_to :widget, class_name: "Widget", foreign_key: "widget_id"
end
```

Associations :through => gadgets
--------------------------------

有一些时候，表之间没有直接的关联关系，但是需要关联起来。`:through`属性允许你定义这种表之间的关联。

``` ruby
class Widget < ActiveRecord::Base
  has_many :gadgets
  has_many :controls, through: gadgets
end
```

`:through` key 允许Widget model通过它的`gadgets`来获得一系列的控制。

`has_many`和`:through`就可以允许many-to-many的关联。

Association `has_and_belongs_to_many` (HABTM)
---------------------------------

`has_and_belongs_to_many` (HABTM) 允许many-to-many关联不用一个单独的实体来实现join表。`:through`join的表是被隐藏起来的。我们这次就不讨论更多`has_and_belongs_many`了。

用`Shoulda`来测试
======================

[`shoulda`](https://github.com/thoughtbot/shoulda)是让测试验证和模型的关联更容易的gem.

验证测试
-------------------

编写定制化的验证测试可能会很冗长，特别是需要验证多个属性的测试的时候。

幼稚的定制化实现：

``` ruby
it "should validate the presence of type" do
  expect {
    Gadget.create!
  }.to raise_error

  expect {
    Gadget.create(type: Gadget::TYPES.sample)
  }.to change { Gadget.count }.by(1)
end
```

使用`shoulda`:

``` ruby
it { should validate_presence_of :type }
```

它们的那套匹配使得测试验证有一种可读的形式。

测试关联
--------------------

关联也是一样的写法：

``` ruby
it { should belong_to :widget }
```

把这样全部放在一起，会让人们创造一种可读的完全specs出来。

``` ruby
describe Widget do
  describe "associations" do
    it { should belong_to(:displayable) }
    it { should have_many :gadgets }
    it { should have_many(:controls).through(:gadgets) }
  end

  describe "validations" do
    it { should validate_presence_of :type }
  end
end
```

使用Object Factory Fabricator进行测试
-----------------------------------------------

通常当在使用request specs或集成测试的时候，都需要为你的测试场景设定虚假的数据。
[fabricator](http://fabricationgem.org/) 或者 [factory_girl](https://github.com/thoughtbot/factory_girl)gem可以创建假数据，和它们的关联，非常的直观。

定义一个Fabricator：

``` ruby
Fabricator(:person) do
  name 'Greg Graffin'
  profession 'Professor/Musician'
end
```

使用fabricator来创建一个`person`的实例，然后在你的数据库里替换掉。

``` ruby
Fabricate(:person)
```

这条语句让人们可以创建request specs和整体测试来运行一组期望的数据。

``` ruby
describe 'home page' do
  before { 3.times { Fabricate(:person) } }
  it "should display people" do
     ...
  end
end
```

这些对象工厂在允许人们设置关联上又进了一步，比如所有的依赖关联都被用来创建特定的对象。

``` ruby
Fabricator(:office) do
  person
  office_number { sequence(:office_number) { |n| n } }
end
```

这里的`person`会自动的关联上制作器用以上定义的`person`。也可以这样来写：

``` ruby
person { Fabricate(:person) }
```

`sequence`关键会保证生成为属性'office_number'生成一个唯一的有序的数。

总结
-------

用[shoulda](https://github.com/thoughtbot/shoulda)在模型层面进行测试驱动，以及在请求层面用[fabricator](http://fabricationgem.org/) 长远的加速了生产力和提升了可维护性。

